#include <encryption/encryption.hpp>
#include <modes.h>
#include <rijndael.h>

namespace Magnus::LibMagnus {
Encryption::Encryption()
{
    mKeys.dh_key.GenerateKeyPair(mRng, mKeys.private_key, mKeys.public_key);
}

Encryption::~Encryption()
{
}

Keys& Encryption::get_keys()
{
    return mKeys;
}

// param pKeys: person B's Keys.
// variable mKeys: person A's keys
SecByteBlock Encryption::generate_shared_key(Keys& pKeys)
{
    // pKeys = Keys that were provided
    // mKeyss = Keys that were generated in the class

    if (pKeys.public_key.empty())
        throw std::runtime_error("Please provide a public key");

    // Check if both keys have equal lengths
    if (mKeys.dh_key.AgreedValueLength() != mKeys.dh_key.AgreedValueLength())
        throw std::runtime_error("Shared shared size mismatch");

    // Shared key
    mSharedKey = SecByteBlock(mKeys.dh_key.AgreedValueLength());

    // Generate shared secret withe locally stored private key
    // and the newly obtaind public key

    if (!mKeys.dh_key.Agree(mSharedKey, mKeys.private_key, pKeys.public_key))
        throw std::runtime_error("Failed to reach shared secret");

    return mSharedKey;
}

Integer Encryption::decode_shared_key(SecByteBlock& shared_key)
{
    Integer shared_secret;
    shared_secret.Decode(shared_key.BytePtr(), shared_key.SizeInBytes());

    return shared_secret;
}

byte* Encryption::encrypt_data_aes_256(SecByteBlock& key, std::string& data, const CryptoPP::byte* iv)
{
    if (key.size() != AES::MAX_KEYLENGTH) {
        throw std::runtime_error("Encryption Key and AES Key lengths don't match.");
    }

    if (AES::BLOCKSIZE != 16) {
        throw std::runtime_error("The block size is NOT 16.");
    }

    byte* encrypted_text = reinterpret_cast<unsigned char*>(data.data());

    // encrypt with the shared key generated by A
    CFB_Mode<AES>::Encryption encryptor(key, AES::MAX_KEYLENGTH, iv);
    encryptor.ProcessData(encrypted_text, encrypted_text, data.size());

    return encrypted_text;
}

byte* Encryption::decrypt_data_aes_256(SecByteBlock& key, std::string& data, const CryptoPP::byte* iv)
{
    if (key.size() != AES::MAX_KEYLENGTH) {
        throw std::runtime_error("Encryption Key and AES Key lengths don't match.");
    }

    if (AES::BLOCKSIZE != 16) {
        throw std::runtime_error("The block size is NOT 16.");
    }

    byte* decrypted_text = reinterpret_cast<byte*>(data.data());

    // encrypt with the shared key generated by A
    CFB_Mode<AES>::Decryption decryptor(key, key.size(), iv);
    decryptor.ProcessData(decrypted_text, decrypted_text, data.size());

    return decrypted_text;
}
};
