#include <magnus.hpp>
#include <modes.h>
#include <rijndael.h>

int main()
{
    auto encryptA = Magnus::LibMagnus::Encryption();
    auto keysA = encryptA.get_keys();

    auto encryptB = Magnus::LibMagnus::Encryption();
    auto keysB = encryptB.get_keys();

    auto sharedA = encryptA.generate_shared_key(keysB);
    auto sharedB = encryptB.generate_shared_key(keysA);

    // Check if the shared secrets are actually equal
    if (sharedA != sharedB)
        throw std::runtime_error("Failed to reach shared secret (C)");

    // Generate a random IV
    SecByteBlock iv(AES::BLOCKSIZE);

    byte plain_text[] = "Hello! How are you.";
    size_t message_len = std::strlen((char*)plain_text) + 1;

    std::cout << plain_text << std::endl;

    // encrypt with the shared key generated by A
    CFB_Mode<AES>::Encryption encryptor(sharedA, AES::MAX_KEYLENGTH, iv);
    encryptor.ProcessData(plain_text, plain_text, message_len);

    std::cout << plain_text << std::endl;

    // decrypt with the shared key generated by B
    CFB_Mode<AES>::Decryption decryptor(sharedB, sharedB.size(), iv);
    decryptor.ProcessData(plain_text, plain_text, message_len);

    std::cout << plain_text << std::endl;

    std::cout << "Agreed to shared secret" << std::endl;
}
